- __index_level_0__: 1
  problem: add_up
  entrypoint: add_up
  assertions: |-
    assert add_up([ [ 'one', 2, 3, 4 ] ]) == 9
    assert add_up([ [ 3, 'hello', 3.4 ] ]) == 6.4
    assert add_up([ [ ] ]) == 0
  username: student1
  submitted_text: |-
    takes a list of strings, integers, and floats and returns the sum of all the numbers.
  prompt: |-
    def add_up(arr):
        """
        $takes:takes$ a $list:list$ of $strings:strings$, $integers:integers$, and floats and $returns:returns$ the sum of all the numbers.
        """
        
  subset: middle_failure
- &id001
  __index_level_0__: 79
  problem: subtract_add
  entrypoint: subtract_add
  assertions: |-
    assert subtract_add(['1', '2', '3', '4']) == -2
    assert subtract_add(['0', '2']) == -2
    assert subtract_add(['0', '0']) == 0
    assert subtract_add([ ]) == 0
  username: student29
  submitted_text: |-
    For each list entry, convert the input to an integer. Multiply list entries that correspond to an odd index by -1. Then add all of the list entries together and return their sum. If the list is empty, return 0.
  prompt: |-
    def subtract_add(lst):
        """
        For each $list:list$ $key:entry$, $typecast:convert$ the $input:input$ to an $integer:integer$. Multiply $list:list$ $keys:entries$ that correspond to an odd index by -1. Then $insert:add$ all of the $list:list$ $keys:entries$ together and $return:return$ their sum. If the $list:list$ is empty, $return:return$ 0.
        """
        
  subset: middle_failure
- *id001
- &id002
  __index_level_0__: 115
  problem: convert
  entrypoint: convert
  assertions: |-
    assert convert([0, 1, 2, 3]) == ['ABCD']
    assert convert([0, -1, 1, -1, 2]) == ['A', 'B', 'C']
    assert convert([1, 1, 1, -1, 25, 25, 25, -1, 0, 1, 2]) == ['BBB', 'ZZZ', 'ABC']
  username: student0
  submitted_text: |-
    takes a list of numbers, have another list with the letters in the alphabet, create an answer list, iterate through the input list, append the letter with the corresponding index of the list with the letters in the alphabet to the answer list, create a new string when encounter a negative number, and return the answer list
  prompt: |-
    def convert(lst):
        """
        $takes:takes$ a $list:list$ of numbers, have another $list:list$ with the letters in the alphabet, create an answer $list:list$, $loop through:iterate through$ the $input:input$ $list:list$, $insert:append$ the letter with the corresponding index of the $list:list$ with the letters in the alphabet to the answer $list:list$, create a new $string:string$ when encounter a negative number, and $return:return$ the answer $list:list$
        """
        
  subset: middle_failure
- *id002
- &id003
  __index_level_0__: 213
  problem: order_strings
  entrypoint: order_strings
  assertions: |-
    assert order_strings(['c', 'b', 'a', 'd']) == ['b', 'a', 'd', 'c']
    assert order_strings([1, 2, 3, 4, 5, 6]) == [3, 2, 1, 6, 5, 4]
    assert order_strings(['hello', 'aaa', 'bbb', 'ccc']) == ['bbb', 'aaa', 'hello', 'ccc']
  username: student17
  submitted_text: |-
    when there are numbers, reversing the order of the first of the list and revering the order of the second half of the list
  prompt: |-
    def order_strings(lst):
        """
        when there are numbers, reversing the order of the first of the $list:list$ and revering the order of the second half of the $list:list$
        """
        
  subset: middle_failure
- *id003
- &id004
  __index_level_0__: 242
  problem: add_int
  entrypoint: add_int
  assertions: |-
    assert add_int(['hello', 'aaa', 'bbb', 'ccc', 1, 4], 5) == ['hello5', 'aaa5', 'bbb5', 'ccc5', 6, 9]
    assert add_int([8, 56, 8, '5', '4'], 1) == [9, 57, 9, '51', '41']
    assert add_int(['hello', 'aaa', 'bbb', ['list'], 1, 4], 5) == ['hello5', 'aaa5', 'bbb5', ['list'], 6, 9]
  username: student38
  submitted_text: |-
    If position in lst is string, append num to string. If position in lst is integer, add num to integer. Else, return position. Return the new lst. 
  prompt: |-
    def add_int(lst, num):
        """
        If position in lst is $string:string$, $insert:append$ num to $string:string$. If position in lst is $integer:integer$, $insert:add$ num to $integer:integer$. Else, $return:return$ position. $Return:Return$ the new lst. 
        """
        
  subset: middle_failure
- *id004
- &id005
  __index_level_0__: 258
  problem: check_prime
  entrypoint: check_prime
  assertions: |-
    assert check_prime('2') == True
    assert check_prime('8') == False
    assert check_prime('9') == False
    assert check_prime('11') == True
  username: student29
  submitted_text: |-
    Convert each input to an integer. If that integer is prime return "True". Else, return "False"
  prompt: |-
    def check_prime(num):
        """
        $Typecast:Convert$ each $input:input$ to an $integer:integer$. If that $integer:integer$ is prime $return:return$ "True". Else, $return:return$ "False"
        """
        
  subset: middle_failure
- *id005
- &id006
  __index_level_0__: 291
  problem: remove_odd
  entrypoint: remove_odd
  assertions: |-
    assert remove_odd([4.3, 4, 5, 2, 7]) == [4.3, 4, 2]
    assert remove_odd([1.1, 2.2, 3.3]) == [1.1, 2.2, 3.3]
    assert remove_odd([3, 5, 7]) == []
  username: student0
  submitted_text: takes in a list of numbers. returns the list of numbers with decimals
    or even numbers.
  prompt: |-
    def remove_odd(lst):
        """
        $takes:takes$ in a $list:list$ of numbers. $returns:returns$ the $list:list$ of numbers with decimals or even numbers.
        """
        
  subset: middle_failure
- *id006
- &id007
  __index_level_0__: 356
  problem: create_list
  entrypoint: create_list
  assertions: |-
    assert create_list({'a': 'b', 't': 'd'}, ['a', 't', 'c']) == ['b', 'd', None]
    assert create_list({1: 'a', 2: 'b', 3: 'c'}, [1, 5, 3]) == ['a', None, 'c']
    assert create_list({3 : 't', 4: 'r', 5: 'e'}, ['a', 'b', 'c']) == [None, None, None]
  username: student36
  submitted_text: |-
    using dt as a reference, return the associated objects of the objects in lst
  prompt: |-
    def create_list(dt, lst):
        """
        using dt as a reference, $return:return$ the associated objects of the objects in lst
        """
        
  subset: middle_failure
- *id007
- &id008
  __index_level_0__: 381
  problem: has_qu
  entrypoint: has_qu
  assertions: |-
    assert has_qu(["A", "B", "C"]) == False
    assert has_qu(["A", "Q", "C"]) == True
    assert has_qu(["A", "U", "C"]) == True
    assert has_qu(["Q", "U"]) == True
  username: student77
  submitted_text: |-
    Given a list of letters, return "True" if the list has a Q or U or both, and "False" if the list does not.
  prompt: |-
    def has_qu(lst):
        """
        Given a $list:list$ of letters, $return:return$ "True" if the $list:list$ has a Q or U or both, and "False" if the $list:list$ does not.
        """
        
  subset: middle_failure
- *id008
- &id009
  __index_level_0__: 389
  problem: planets_mass
  entrypoint: planets_mass
  assertions: |-
    assert planets_mass({'Venus': 10, 'Mercury': 5, 'Sun': 100}) == 15
    assert planets_mass({'Pluto': 30, 'Venus': 10, 'Mercury': 5, 'Sun': 100}) == 15
    assert planets_mass({'Pluto': 100}) == 0
  username: student14
  submitted_text: |-
    if planet mass is less than 16, add up the total planet mass in each bracket
  prompt: |-
    def planets_mass(planets):
        """
        if planet mass is less than 16, $insert:add$ up the total planet mass in each bracket
        """
        
  subset: middle_failure
- *id009
- &id010
  __index_level_0__: 428
  problem: student_grades
  entrypoint: student_grades
  assertions: |-
    assert student_grades({'Alice': 20, 'Bob': 11}, {20: ['A','A'], 11: ['A','B'], 21: ['B']}) == {'Alice': ['A','A'], 'Bob': ['A','B']}
    assert student_grades({'Alice': 20}, {20: [], 11: ['A','B'], 21: ['A-']}) == {'Alice': []}
    assert student_grades({'Sam': 21, 'Ari': 67, 'Chris': 23}, {67: [], 23: ['A'], 21: ['B','B']}) == {'Sam': ['B', 'B'], 'Ari':[], 'Chris':['A'] }
  username: student5
  submitted_text: 'the function student_grades will take two inputs of students and
    grades. Students will have a name and then a score. Grades will have a number
    and a range of letter grades. The function should return the name of a student
    with the range of letter grade they got based on their score. '
  prompt: |-
    def student_grades(students, grades):
        """
        the function student_grades will $take:take$ two $inputs:inputs$ of students and grades. Students will have a name and then a score. Grades will have a number and a range of letter grades. The function should $return:return$ the name of a student with the range of letter grade they got based on their score. 
        """
        
  subset: middle_failure
- *id010
- &id011
  __index_level_0__: 447
  problem: times_with
  entrypoint: times_with
  assertions: |-
    assert times_with([ [30, ['Alice', 'Bob', 'Carol']] ]) == { 'Alice': 30, 'Bob': 30, 'Carol': 30 }
    assert times_with([ [30, ['Alice', 'Bob', 'Carol']], [20, ['Alice', 'Bob']] ]) == { 'Alice': 50, 'Bob': 50, 'Carol': 30 }
    assert times_with([ [10, ['Alice', 'Bob']], [5, ['Carol']] ]) == {'Alice': 10, 'Bob': 10, 'Carol': 5}
  username: student23
  submitted_text: |-
    This function takes in a list within a list, consisting of the age as an integer, and names as a string. The output creates a dictionary where the key is the name and appends the value which is the age that is given. 
  prompt: |-
    def times_with(meetings):
        """
        This function $takes:takes$ in a $list:list$ within a $list:list$, consisting of the age as an $integer:integer$, and names as a $string:string$. The $return:output$ creates a $dictionary:dictionary$ where the $key:key$ is the name and $inserts:appends$ the value which is the age that is given. 
        """
        
  subset: middle_failure
- *id011
- &id012
  __index_level_0__: 498
  problem: meeps_morps
  entrypoint: meeps_morps
  assertions: |-
    assert meeps_morps(['Meep', 'Morp', 'Meep', 'Meep', 'Suitcase', 'Kind', 'Morp']) == [3,2]
    assert meeps_morps(['Meep', 'Meep', 'Suitcase', 'Kind']) == [2,0]
    assert meeps_morps(['Suitcase', 'Kind', 'Carrot', 'Meat', 'Morpling']) == [0,0]
  username: student16
  submitted_text: count the number of 'Meep' and 'Morp' in a list
  prompt: |-
    def meeps_morps(items):
        """
        count the number of 'Meep' and 'Morp' in a $list:list$
        """
        
  subset: middle_failure
- *id012
- &id013
  __index_level_0__: 513
  problem: print_time
  entrypoint: print_time
  assertions: |-
    assert print_time('Sat', 12) == 'weekend'
    assert print_time('Sun', 12) == 'weekend'
    assert print_time('Mon', 9) == 'weekday'
    assert print_time('Tue', 23) == 'weekday'
    assert print_time('Wed', 0) == 'sleeping'
    assert print_time('Thu', 8) == 'sleeping'
  username: student12
  submitted_text: |-
    Return if the day of the week is a weekday or weekend if the hour is not between 0 and 8. Else, return sleeping.
  prompt: |-
    def print_time(day,hour):
        """
        $Return:Return$ if the day of the week is a weekday or weekend if the hour is not between 0 and 8. Else, $return:return$ sleeping.
        """
        
  subset: middle_failure
- *id013
- &id014
  __index_level_0__: 542
  problem: mod_end
  entrypoint: mod_end
  assertions: |-
    assert mod_end(['jumping', 'bumping', 'singing', 'picking'], 'ing') == ['jumps', 'bumps', 'sings', 'picks']
    assert mod_end(['dreaded', 'edited', 'heated'], 'ed') == ['dreads', 'edits', 'heats']
    assert mod_end(['nearer', 'closer'], 'er') == ['nears', 'closs']
  username: student20
  submitted_text: |-
    Take a list of words sharing the same ending, and a string as an input.
    Search the last letters of each word in the list for the string, and replace it with 's'.
  prompt: |-
    def mod_end(words, ending):
        """
        $Take:Take$ a $list:list$ of $strings:words$ sharing the same ending, and a $string:string$ as an $input:input$.
    Search the last letters of each $string:word$ in the $list:list$ for the $string:string$, and replace it with 's'.
        """
        
  subset: middle_failure
- *id014
- &id015
  __index_level_0__: 562
  problem: increaseScore
  entrypoint: increaseScore
  assertions: |-
    assert increaseScore(-10) == 10
    assert increaseScore(1) == 10
    assert increaseScore(10) == 11
    assert increaseScore(15) == 16
    assert increaseScore(20) == 21
  username: student23
  submitted_text: This function takes in a number and adds one if the number is greater
    than 9. If the number is negative it turns into a positive number. If it is a
    single-digit number it adds a zero to the end of the number. Then the output is
    returned with the updated number.
  prompt: |-
    def increaseScore(score):
        """
        This function $takes:takes$ in a number and $inserts:adds$ one if the number is greater than 9. If the number is negative it $typecasts:turns$ into a positive number. If it is a single-digit number it $inserts:adds$ a zero to the end of the number. Then the $return:output$ is $returned:returned$ with the updated number.
        """
        
  subset: middle_failure
- *id015
- &id016
  __index_level_0__: 592
  problem: getSeason
  entrypoint: getSeason
  assertions: |-
    assert getSeason('January') == 'winter'
    assert getSeason('April') == 'spring'
    assert getSeason('August') == 'summer'
    assert getSeason('October') == 'fall'
  username: student6
  submitted_text: 'Function takes in the name of an inputted month of the year and
    outputs the season that the month is in '
  prompt: |-
    def getSeason(month):
        """
        Function $takes:takes$ in the name of an $inputted:inputted$ month of the year and $returns:outputs$ the season that the month is in 
        """
        
  subset: middle_failure
- *id016
- &id017
  __index_level_0__: 649
  problem: assessVowels
  entrypoint: assessVowels
  assertions: |-
    assert assessVowels('I ate an apple') == ['I', 'a', 'e', 'a', 'a', 'e']
    assert assessVowels('Another string here') == ['A', 'o', 'e', 'i', 'e', 'e']
    assert assessVowels('cAbbAge') == ['A', 'A', 'e']
    assert assessVowels('') == []
  username: student2
  submitted_text: This function pints a list containing strings of every vowel from
    the input
  prompt: |-
    def assessVowels(s):
        """
        This function pints a $list:list$ containing $strings:strings$ of every vowel from the $input:input$
        """
        
  subset: middle_failure
- *id017
- &id018
  __index_level_0__: 682
  problem: hasHorizontalWin
  entrypoint: hasHorizontalWin
  assertions: |-
    assert hasHorizontalWin([['', '',  'X', 'O', 'X'],
    ['X', 'X', 'X', 'X', 'X'],
    ['X', 'O', 'X', 'O', 'O'],
    ['',  '',  '',  'X', 'O'],
    ['',  '',  '',  '',  'O']],
    'X') == True
    assert hasHorizontalWin([['', '',  'X', 'O', 'X'],
    ['X', 'X', 'X', 'X', 'O'],
    ['X', 'X', 'X', 'O', 'O'],
    ['',  '',  '',  'X', 'O'],
    ['',  '',  '',  '',  'O']],
    'X') == False
    assert hasHorizontalWin([['', '',  'X', 'O', 'X'],
    ['X', 'X', 'O', 'X', 'O'],
    ['X', 'O', 'X', 'O', 'O'],
    ['',  '',  '',  'X', 'O'],
    ['',  '',  '',  '',  'O']],
    'X') == False
  username: student44
  submitted_text: Return true if there is an index that contains the same value in
    all the arrays in the array or there is an array with all the same values.
  prompt: |-
    def hasHorizontalWin(board, letter):
        """
        $Return:Return$ true if there is an index that contains the same value in all the $lists:arrays$ in the $list:array$ or there is an $list:array$ with all the same values.
        """
        
  subset: middle_failure
- *id018
- &id019
  __index_level_0__: 708
  problem: readingIceCream
  entrypoint: readingIceCream
  assertions: |-
    assert readingIceCream(["peppermint\tice cream\t3",
    "lemon\tfrozen yogurt\t10",
    "pumpkin\tice cream\t2.5",
    "monster\tice cream\t21"]) == 36.5
    assert readingIceCream(["salty\tfrozen yogurt\t10"]) == 10
    assert readingIceCream(["salty\tfrozen yogurt\t0"]) == 0
  username: student29
  submitted_text: |
    For each list entry, parse through the string and keep track of the number of "\" characters. When the number of "\" is 2, isolate the rest of the string. Then isolate the remainder of that string, starting at index 1. Convert this string to a float. Keep track of the float for each entry and add them all together, returning the sum for each list
  prompt: |-
    def readingIceCream(lines):
        """
        For each $list:list$ $key:entry$, parse through the $string:string$ and keep track of the number of "\" $strings:characters$. When the number of "\" is 2, isolate the rest of the $string:string$. Then isolate the remainder of that $string:string$, starting at index 1. $Typecast:Convert$ this $string:string$ to a float. Keep track of the float for each $key:entry$ and $insert:add$ them all together, $returning:returning$ the sum for each $list:list$

        """
        
  subset: middle_failure
- *id019
- &id020
  __index_level_0__: 751
  problem: findHorizontals
  entrypoint: findHorizontals
  assertions: |-
    assert findHorizontals(["ztac","zzzz","teaz","part","zzzz"],
    ["cat","dog","tea","party"]) == {"cat":0, "tea":2}
    assert findHorizontals(["ztac","zzzz","teaz","part","zzzz"],
    ["to","apple","ape","party"]) == {}
    assert findHorizontals(["as", "be", "sa", "it"],
    ["it"]) == {'it': 3}
  username: student27
  submitted_text: The input will be a "puzzle" list and a "wordList" list. They consist
    of strings and have equal length. Check if the string in the puzzle list contains
    all the characters of the string in the wordList list. They don't have to be in
    the same order. Return a dictionary with the string as the key and the position
    of the string as the value.
  prompt: |-
    def findHorizontals(puzzle,wordList):
        """
        The $input:input$ will be a "puzzle" $list:list$ and a "wordList" $list:list$. They consist of $strings:strings$ and have equal length. Check if the $string:string$ in the puzzle $list:list$ contains all the $strings:characters$ of the $string:string$ in the wordList $list:list$. They don't have to be in the same order. $Return:Return$ a $dictionary:dictionary$ with the $string:string$ as the $key:key$ and the position of the $string:string$ as the value.
        """
        
  subset: middle_failure
- *id020
- &id021
  __index_level_0__: 785
  problem: partialWordle
  entrypoint: partialWordle
  assertions: |-
    assert partialWordle(["zzzz","bbbb","lyre","part","apes"],
    'pare') == [0,0,4,6,3]
    assert partialWordle(["aaaa","wall","woah","deal","howl"],
    "word") == [0,2,4,1,3]
    assert partialWordle(["real","hill","ream","meal","curl"],
    "roll") == [4,4,2,2,3]
  username: student9
  submitted_text: The function prints how many letters each string in the list shares
    with the string outside the list.
  prompt: |-
    def partialWordle(guessList,hiddenWord):
        """
        The function $returns:prints$ how many letters each $string:string$ in the $list:list$ shares with the $string:string$ outside the $list:list$.
        """
        
  subset: middle_failure
- *id021
- &id022
  __index_level_0__: 820
  problem: andCount
  entrypoint: andCount
  assertions: |-
    assert andCount(['--&-','----','-&--','---&',]) == 3
    assert andCount(['&&&-','-----','--&&&','-----',]) == 6
    assert andCount(['----', '----', '----', '----']) == 0
  username: student67
  submitted_text: |-
    If '&' in an item of the list, and majority '-', returns the lowest number of dashes in an item times 3. If the majority of the input in an item is '&', returns the highest number of & times 2. Returns 0 if there aren't both & and -.
  prompt: |-
    def andCount(andGrid):
        """
        If '&' in an $key:item$ of the $list:list$, and majority '-', $returns:returns$ the lowest number of dashes in an $key:item$ times 3. If the majority of the $input:input$ in an $key:item$ is '&', $returns:returns$ the highest number of & times 2. $Returns:Returns$ 0 if there aren't both & and -.
        """
        
  subset: middle_failure
- *id022
- &id023
  __index_level_0__: 834
  problem: set_chars
  entrypoint: set_chars
  assertions: |-
    assert set_chars('Everybody loves apples.', "u", [0,2,6,16]) == 'uvurybudy loves upples.'
    assert set_chars('ice cream is the best', 'q', [1,21]) == 'iqe cream is the best'
    assert set_chars('toast and jam and toast and ham', 't', []) == 'toast and jam and toast and ham'
  username: student20
  submitted_text: Replace letters in input s that are located in index l to the input
    c
  prompt: |-
    def set_chars(s,c,l):
        """
        Replace letters in $input:input$ s that are located in index l to the $input:input$ c
        """
        
  subset: middle_failure
- *id023
- &id024
  __index_level_0__: 859
  problem: altText
  entrypoint: altText
  assertions: |-
    assert altText('I love to see dolphins swim.') == 'I LoVe tO SeE DoLpHiNs sWiM.'
    assert altText('computers') == 'CoMpUtErS'
    assert altText('t') == 'T'
  username: student23
  submitted_text: |-
    This function takes in a word or sentence and outputs every other letter as upper case, not including the lower case letters. If it is just a one letter word it is turned into an upper case letter. 
  prompt: |-
    def altText(s):
        """
        This function $takes:takes$ in a $string:word$ or sentence and $returns:outputs$ every other letter as upper case, not including the lower case letters. If it is just a one letter $string:word$ it is $typecasted:turned$ into an upper case letter. 
        """
        
  subset: middle_failure
- *id024
- &id025
  __index_level_0__: 900
  problem: changeSection
  entrypoint: changeSection
  assertions: |-
    assert changeSection('Turn towards the door.', 9) == 'awot nruTrds the door.'
    assert changeSection('the tall sail', 13) == 'lias llat eht'
    assert changeSection('establishing', 1) == 'establishing'
  username: student3
  submitted_text: 'create a function which make the order of i first letters of the
    string backward '
  prompt: |-
    def changeSection(s,i):
        """
        create a function which make the order of i first letters of the $string:string$ backward 
        """
        
  subset: middle_failure
- *id025
- &id026
  __index_level_0__: 957
  problem: edit_col
  entrypoint: edit_col
  assertions: |-
    assert edit_col([[1,2,3], [4,5,6], [7,8,9]], 1, 6) == [[1,6,3], [4,6,6], [7,6,9]]
    assert edit_col([[1,1,1,1,1], [1,1,1,1,1]], 0, 9) == [[9,1,1,1,1], [9,1,1,1,1]]
    assert edit_col([[2,3]], 1, 1) == [[2,1]]
  username: student67
  submitted_text: Replaces the first item of the last list with the sum of i and n.
  prompt: |-
    def edit_col(mat,i,n):
        """
        Replaces the first $key:item$ of the last $list:list$ with the sum of i and n.
        """
        
  subset: middle_failure
- *id026
- &id027
  __index_level_0__: 967
  problem: combine
  entrypoint: combine
  assertions: |-
    assert combine([[1,2,3],[4,5,6],[7,8,9]],[[10,20,30],[40,50,60],[70,80,90]]) == [[1,2,3,10,20,30],[4,5,6,40,50,60],[7,8,9,70,80,90]]
    assert combine([[9,8,7]], [[0,1,2]]) == [[9,8,7,0,1,2]]
    assert combine([[2,3],[1,1],[10,11],[4, 5]],[[1, 1],[14, 15],[3, 2],[77, 87]]) == [[2,3,1,1],[1,1,14,15],[10,11,3,2],[4,5,77,87]]
  username: student20
  submitted_text: Take two lists and combine them
  prompt: |-
    def combine(l1,l2):
        """
        $Take:Take$ two $lists:lists$ and $concatenate:combine$ them
        """
        
  subset: middle_failure
- *id027
- &id028
  __index_level_0__: 988
  problem: pattern
  entrypoint: pattern
  assertions: |-
    assert pattern(3) == [[1,2,3],[1,2,3],[1,2,3]]
    assert pattern(4) == [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]
    assert pattern(2) == [[1,2],[1,2]]
  username: student3
  submitted_text: create function which take 1 input (value). create list of ascending
    numbers of value
  prompt: |-
    def pattern(value):
        """
        create function which $take:take$ 1 $input:input$ (value). create $list:list$ of ascending numbers of value
        """
        
  subset: middle_failure
- *id028
- &id029
  __index_level_0__: 1024
  problem: reduce
  entrypoint: reduce
  assertions: |-
    assert reduce('^^1-1^^') == '__1-1__'
    assert reduce('~^--^~') == '~_--_~'
    assert reduce('|O.0|') == '|O.0|'
  username: student26
  submitted_text: |-
    Count the characters in a string and replace all '^' as '_', then return a copy of the new string
  prompt: |-
    def reduce(val):
        """
        Count the $strings:characters$ in a $string:string$ and replace all '^' as '_', then $return:return$ a copy of the new $string:string$
        """
        
  subset: middle_failure
- *id029
- &id030
  __index_level_0__: 1033
  problem: fib
  entrypoint: fib
  assertions: |-
    assert fib(1) == True
    assert fib(13) == True
    assert fib(21) == True
    assert fib(19) == False
  username: student2
  submitted_text: this function returns false if the value contains a '9' but returns
    true if the value does not contain a 9
  prompt: |-
    def fib(n):
        """
        this function $returns:returns$ false if the value contains a '9' but $returns:returns$ true if the value does not contain a 9
        """
        
  subset: middle_failure
- *id030
- &id031
  __index_level_0__: 1067
  problem: add_word
  entrypoint: add_word
  assertions: |-
    assert add_word('bright', 1, {'twas': [1]}) == {'twas': [1], 'bright': [1]}
    assert add_word('five', 5, {'one': [1], 'three': [3, 3, 3, 5], 'five': [3, 5, 5, 5, 5]}) == {'one': [1], 'three': [3, 3, 3, 5], 'five': [3, 5, 5, 5, 5, 5]}
    assert add_word('laughing', 7, {'i': [1, 6], 'heard': [1], 'a': [1, 4], 'asked': [6]}) == {'i': [1, 6], 'heard': [1], 'a': [1, 4], 'asked': [6], 'laughing': [7]}
  username: student3
  submitted_text: |-
    create a function with 3 input word(string), line_number (int) and map (dict). add new key name word and its corresponding list of line_number into the map
  prompt: |-
    def add_word(word, line_number, $dictionary:map$):
        """
        create a function with 3 $input:input$ word(string), line_number ($integer:int$) and $dictionary:map$ (dict). $insert:add$ new $key:key$ name $string:word$ and its corresponding $list:list$ of line_number into the $dictionary:map$
        """
        
  subset: middle_failure
- *id031
- &id032
  __index_level_0__: 1092
  problem: check_for_aspen
  entrypoint: check_for_aspen
  assertions: |-
    assert check_for_aspen({"Oak": 3, "Birch": 5, "Elm": 2}) == "Nope"
    assert check_for_aspen({"Aspen": 7, "Beech": 15}) == "Yup"
    assert check_for_aspen({"Beech": 8, "Maple": 2, "Aspen": 3}) == "Yup"
  username: student27
  submitted_text: |-
    Check if "aspen" is a key in a dictionary. Return "Yup" if it is a key, "Nope" if it is not a key.
  prompt: |-
    def check_for_aspen(trees):
        """
        Check if "aspen" is a $key:key$ in a $dictionary:dictionary$. $Return:Return$ "Yup" if it is a $key:key$, "Nope" if it is not a $key:key$.
        """
        
  subset: middle_failure
- *id032
- &id033
  __index_level_0__: 1132
  problem: multisplit
  entrypoint: multisplit
  assertions: |-
    assert multisplit("a man! wow- the dog, much hat! much hair!",['-','!','?',','],'~') == 'a man~ wow~ the dog~ much hat~ much hair~'
    assert multisplit('celestial teas: a guide',[' ',':'],'!') == 'celestial!teas!!a!guide'
    assert multisplit('celestial teas: a guide',[],'!') == 'celestial teas: a guide'
  username: student45
  submitted_text: |-
    Takes three inputs: a string which we will call s, a list of strings which we will call chars, and another string which we will call sep. At each point in s where a string from chars is present, we split s, remove the character from s at the index where we split, and insert sep.
  prompt: |-
    def multisplit(s,chars,sep):
        """
        $Takes:Takes$ three $inputs:inputs$: a $string:string$ which we will call s, a $list:list$ of $strings:strings$ which we will call chars, and another $string:string$ which we will call sep. At each point in s where a $string:string$ from chars is present, we split s, $skip:remove$ the $string:character$ from s at the index where we split, and $insert:insert$ sep.
        """
        
  subset: middle_failure
- *id033
- &id034
  __index_level_0__: 1144
  problem: sortedBooks
  entrypoint: sortedBooks
  assertions: |-
    assert sortedBooks([{'author': 'Austen', 'book': 'Emma', 'year': 1815},
    {'author': 'Austen', 'book': 'Persuasion', 'year': 1818}, 
    {'author': 'Woolf', 'book': 'The Voyage Out', 'year': 1915}, 
    {'author': 'Austen', 'book': 'Pride and Prejudice', 'year': 1813}], 
    'Austen') == [{'author': 'Austen', 'book': 'Pride and Prejudice', 'year': 1813},
    {'author': 'Austen', 'book': 'Emma', 'year': 1815}, 
    {'author': 'Austen', 'book': 'Persuasion', 'year': 1818}]
    assert sortedBooks([{'author': 'Woolf', 'book': 'The Voyage Out', 'year': 1915},
      {'author': 'Austen', 'book': 'Persuasion', 'year': 1818}], 
      'Woolf') == [{'author': 'Woolf', 'book': 'The Voyage Out', 'year': 1915}]
    assert sortedBooks([{'author': 'Woolf', 'book': 'The Voyage Out', 'year': 1915}],
      'Austen') == []
  username: student29
  submitted_text: |-
    Check the second parameter of the input for the string of author name. Then return all input entries where the author value corresponds to that parameter, with a line break between each entry
  prompt: |-
    def sortedBooks(books, writer):
        """
        Check the second $parameter:parameter$ of the $input:input$ for the $string:string$ of author name. Then $return:return$ all $input:input$ $keys:entries$ where the author value corresponds to that $parameter:parameter$, with a line break between each $key:entry$
        """
        
  subset: middle_failure
- *id034
- &id035
  __index_level_0__: 1179
  problem: sortBySuccessRate
  entrypoint: sortBySuccessRate
  assertions: |-
    assert sortBySuccessRate([{'nominee': 'Jones', 'wins': 28, 'noms': 80}, 
    {'nominee': 'Beyoncé',  'wins': 28, 'noms': 79}, 
    {'nominee': 'Krauss',  'wins': 27, 'noms': 42}]) == [{'nominee': 'Krauss', 'wins': 27, 'noms': 42, 'success': 0.64}, 
    {'nominee': 'Jones', 'wins': 28, 'noms': 80, 'success': 0.35}, 
    {'nominee': 'Beyoncé', 'wins': 28, 'noms': 79, 'success': 0.35}]
    assert sortBySuccessRate([{'nominee': 'Babyface','wins': 11, 'noms': 49},
    {'nominee': 'Swift', 'wins': 11, 'noms': 41}, 
    {'nominee': 'Thomas', 'wins': 11, 'noms': 38}]) == [{'nominee': 'Thomas', 'wins': 11, 'noms': 38, 'success': 0.29},
    {'nominee': 'Swift', 'wins': 11, 'noms': 41, 'success': 0.27},
    {'nominee': 'Babyface', 'wins': 11, 'noms': 49, 'success': 0.22}]
    assert sortBySuccessRate([{'nominee': 'Beyoncé', 'wins': 28, 'noms': 79},
     {'nominee': 'Babyface','wins': 11, 'noms': 49}]) == [{'nominee': 'Beyoncé', 'wins': 28, 'noms': 79, 'success': 0.35}, 
    {'nominee': 'Babyface', 'wins': 11, 'noms': 49, 'success': 0.22}]
  username: student23
  submitted_text: |-
    This function takes in a list of dictionaries that have the nominee, the amount of wins, and the amount of noms. A new attribute is given to each dictionary which is the success attribute. It is calculated by dividing wins by noms and creates a float. The lists are then sorted by the highest success within each dictionary.
  prompt: |-
    def sortBySuccessRate(nominations):
        """
        This function $takes:takes$ in a $list:list$ of $dictionaries:dictionaries$ that have the nominee, the amount of wins, and the amount of noms. A new $key:attribute$ is given to each $dictionary:dictionary$ which is the success $key:attribute$. It is calculated by dividing wins by noms and creates a float. The $lists:lists$ are then sorted by the highest success within each $dictionary:dictionary$.
        """
        
  subset: middle_failure
- *id035
- &id036
  __index_level_0__: 1226
  problem: layoverTrips
  entrypoint: layoverTrips
  assertions: |-
    assert layoverTrips([{'origin':'BOS', 'dest':'ORD', 'hrs':2.0}, 
    {'origin':'BOS', 'dest':'JFK', 'hrs':1.0},
    {'origin':'JFK', 'dest':'LAX', 'hrs':1.0},
    {'origin':'LAX', 'dest':'SEA', 'hrs':1.0},
    {'origin':'JFK', 'dest':'ATL', 'hrs':1.0}], 'BOS') == ['ATL','LAX']
    assert layoverTrips([{'origin':'BOS', 'dest':'ORD', 'hrs':2.0}, 
    {'origin':'BOS', 'dest':'JFK', 'hrs':1.0},
    {'origin':'ORD', 'dest':'SEA', 'hrs':1.0}], 'ORD') == []
    assert layoverTrips([{'origin':'LAX', 'dest':'SEA', 'hrs':1.0},
     {'origin':'SEA', 'dest':'JFK', 'hrs':2.0},
     {'origin':'SEA', 'dest':'ATL','hrs':1.0}], 'LAX') == ['ATL','JFK']
  username: student5
  submitted_text: this function will take a list of flights and the starting city
    and return the possible layovers with the staring city
  prompt: |-
    def layoverTrips(flights, start):
        """
        this function will $take:take$ a $list:list$ of flights and the starting city and $return:return$ the possible layovers with the staring city
        """
        
  subset: middle_failure
- *id036
- &id037
  __index_level_0__: 1242
  problem: sort_physicists
  entrypoint: sort_physicists
  assertions: |-
    assert sort_physicists([["Youyou",91,"Chemistry"],["Ghez",56,"Physics"],["Peiris",48,"Physics"],["Strickland",62,"Physics"]]) == ['Peiris', 'Ghez', 'Strickland']
    assert sort_physicists([["Ghez",56,"Physics"],["Peiris",48,"Physics"],["Strickland",62,"Physics"]]) == ['Peiris', 'Ghez', 'Strickland']
    assert sort_physicists([["Taylor",59,"Computer Science"],["Tu",91,"Chemistry"],["Ghez",56,"Physics"]]) == ['Ghez']
  username: student12
  submitted_text: Create a list of the 0th element in the list within the list if
    the 2nd element says "Physics". Sort the list from least to greatest by looking
    at the 1st value in the list within the big list. Return this sorted list
  prompt: |-
    def sort_physicists(scientists):
        """
        Create a $list:list$ of the 0th $key:element$ in the $list:list$ within the $list:list$ if the 2nd $key:element$ says "Physics". Sort the $list:list$ from least to greatest by looking at the 1st value in the $list:list$ within the big $list:list$. $Return:Return$ this sorted $list:list$
        """
        
  subset: middle_failure
- *id037
- &id038
  __index_level_0__: 1277
  problem: find_multiples
  entrypoint: find_multiples
  assertions: |-
    assert find_multiples(1,100,20) == [20, 40, 60, 80, 100]
    assert find_multiples(10, 30, 5) == [10, 15, 20, 25, 30]
    assert find_multiples(1000,2000,177) == [1062, 1239, 1416, 1593, 1770, 1947]
  username: student2
  submitted_text: This function prints the start value and adds the factor until it
    reaches the stop value
  prompt: |-
    def find_multiples(start,stop,factor):
        """
        This function $returns:prints$ the start value and $inserts:adds$ the factor until it reaches the stop value
        """
        
  subset: middle_failure
- *id038
- &id039
  __index_level_0__: 1309
  problem: total_bill
  entrypoint: total_bill
  assertions: |-
    assert total_bill([['apples', 6, 0.99],['milk', 1, 1.49],['bread', 2, 3.50]], 0.07) == 15.44
    assert total_bill([['apples', 6, 0.99],['milk', 1, 1.49],['bread', 2, 3.50]], 0.0) == 14.43
    assert total_bill([['bread', 2, 3.50]], 0.5) == 10.5
  username: student23
  submitted_text: |-
    This function takes in a list of the item purchased, the price, the tax, and the overall sales tax. All of the prices and taxes within the lists are added together. The sales tax is then multiplied by the outcome of the added prices, and then the result of the multiplication is added onto the total price. The total price is then returned as the output.
  prompt: |-
    def total_bill(grocery_list, sales_tax):
        """
        This function $takes:takes$ in a $list:list$ of the $key:item$ purchased, the price, the tax, and the overall sales tax. All of the prices and taxes within the $lists:lists$ are $inserted:added$ together. The sales tax is then multiplied by the outcome of the $inserted:added$ prices, and then the result of the multiplication is $inserted:added$ onto the total price. The total price is then $returned:returned$ as the $return:output$.
        """
        
  subset: middle_failure
- *id039
- &id040
  __index_level_0__: 1356
  problem: translate
  entrypoint: translate
  assertions: |-
    assert translate({"one":"un", "two":"deux", "three":"trois", "four":"quatre",
      "I":"je", "you":"tu", "and":"et", "cats":"chats", "love":"aime",
      "like":"aime", "my":"mes"}, 
      "I like my three cats") == 'je aime mes trois chats'
    assert translate({"one":"un", "two":"deux", "three":"trois", "four":"quatre",
      "I":"je", "you":"tu", "and":"et", "cats":"chats", "love":"aime",
      "like":"aime", "my":"mes"}, 
      "I like my three marmots") == 'je aime mes trois UNK'
    assert translate({"one":"ett", "two":"tva", "three":"tre", "four":"fyra"},
    "five six seven eight") == 'UNK UNK UNK UNK'
  username: student60
  submitted_text: |-
    This function takes in a dictionary and a string as parameters. The dictionary contains the translation of given english words. The function then prints the string in french. If a word in the function is not in the dictionary, the function prints 'UNK' for that word. 
  prompt: |-
    def translate(lexicon,sentence):
        """
        This function $takes:takes$ in a $dictionary:dictionary$ and a $string:string$ as $parameters:parameters$. The $dictionary:dictionary$ contains the translation of given english $strings:words$. The function then $returns:prints$ the $string:string$ in french. If a $string:word$ in the function is not in the $dictionary:dictionary$, the function $returns:prints$ 'UNK' for that $string:word$. 
        """
        
  subset: middle_failure
- *id040
- &id041
  __index_level_0__: 1377
  problem: topScores
  entrypoint: topScores
  assertions: |-
    assert topScores([[76, 'Matt'], [80, 'Rachel'], [100, 'Penelope'], [50, 'Pete'], [99, 'Alex']]) == ['Penelope', 'Alex', 'Rachel']
    assert topScores([[92, 'Kip'], [76, 'Matt'], [80, 'Sam'], [100, 'Ben'], [99, 'Alex'], [97, 'Ro'], [65, 'Hans'], [95, 'Ira']]) == ['Ben', 'Alex', 'Ro', 'Ira', 'Kip']
    assert topScores([[65, 'Bob'], [65, 'Rachel'], [33, 'Alex']]) == []
  username: student7
  submitted_text: |
    Iterates through a list of lists, with each list housing the age and name of a person respectively. Returns a list of the names of people from oldest to youngest, as long as there is less than a 10-year gap between the two. 
  prompt: |-
    def topScores(lst):
        """
        Iterates through a $list:list$ of $lists:lists$, with each $list:list$ housing the age and name of a person respectively. $Returns:Returns$ a $list:list$ of the names of people from oldest to youngest, as long as there is less than a 10-year gap between the two. 

        """
        
  subset: middle_failure
- *id041
- &id042
  __index_level_0__: 1462
  problem: generateCardDeck
  entrypoint: generateCardDeck
  assertions: |-
    assert generateCardDeck(['S', 'H', 'D'], ['1', '2', 'A']) == ['D1', 'D2', 'DA', 'H1', 'H2', 'HA',  'S1', 'S2', 'SA']
    assert generateCardDeck(['H', 'D'], ['6', 'Q', 'J', '2']) == ['D2', 'D6', 'DJ', 'DQ', 'H2','H6', 'HJ', 'HQ']
    assert generateCardDeck(['H'], ['2']) == ['H2']
  username: student23
  submitted_text: 'This function inputs two lists. The letter at the end of the first
    list adds on the lowest number of the second dictionary. This keeps going and
    forms a new list with all the combined letters and numbers. '
  prompt: |-
    def generateCardDeck(suits, vals):
        """
        This function $inputs:inputs$ two $lists:lists$. The letter at the end of the first $list:list$ $inserts:adds$ on the lowest number of the second $dictionary:dictionary$. This keeps going and forms a new $list:list$ with all the $concatenated:combined$ letters and numbers. 
        """
        
  subset: middle_failure
- *id042
- &id043
  __index_level_0__: 1541
  problem: reverseWords
  entrypoint: reverseWords
  assertions: |-
    assert reverseWords(['eat', 'tree']) == ['eert', 'tae']
    assert reverseWords(['ax', 'by', 'chaz']) == ['xa', 'yb', 'zahc']
    assert reverseWords(['by', 'chaz', 'ax']) == ['xa', 'yb', 'zahc']
  username: student1
  submitted_text: |-
    takes a list of words, reverses them and orders them in alphabetical order.
  prompt: |-
    def reverseWords(words):
        """
        $takes:takes$ a $list:list$ of $strings:words$, reverses them and orders them in alphabetical order.
        """
        
  subset: middle_failure
- *id043
- &id044
  __index_level_0__: 1586
  problem: percentWin
  entrypoint: percentWin
  assertions: |-
    assert percentWin(['1', '1', 'X', '2'], ['1', '1', '1', '2']) == '75%'
    assert percentWin(['2', 'X', 'X'], ['2', '2', '2']) == '33%'
    assert percentWin(['2', '1', '2', '1', '2'], ['2', '1', '2', '1', '2']) == '100%'
  username: student3
  submitted_text: |-
    create a function with 2 inputs: guess (list) and answers(list). find the number of the element match in guess and answers then divide with the number of element of answers. then times the results 100 times and round up the to interger
  prompt: |-
    def percentWin(guess,answers):
        """
        create a function with 2 $inputs:inputs$: guess ($list:list$) and answers(list). find the number of the $key:element$ match in guess and answers then divide with the number of $key:element$ of answers. then times the results 100 times and round up the to interger
        """
        
  subset: middle_failure
- *id044
- &id045
  __index_level_0__: 1651
  problem: exp
  entrypoint: exp
  assertions: |-
    assert exp([1, 2, 3], 1) == [1,2,3]
    assert exp([2,2,2], 3) == [8,8,8]
    assert exp([2], 2) == [4]
  username: student14
  submitted_text: multiply numbers in brackets by number outside of brackets. Return
    finished equation
  prompt: |-
    def exp(lst, val):
        """
        multiply numbers in $lists:brackets$ by number outside of $lists:brackets$. $Return:Return$ finished equation
        """
        
  subset: middle_failure
- *id045
- &id046
  __index_level_0__: 1670
  problem: laugh
  entrypoint: laugh
  assertions: |-
    assert laugh(4) == "haaaa haaa haa ha"
    assert laugh(1) == "ha"
    assert laugh(3) == "haaa haa ha"
  username: student2
  submitted_text: 'This function prints "ha" for an input of 1. This function prints
    an additional "haa" for an input greater than 1 '
  prompt: |-
    def laugh(size):
        """
        This function $returns:prints$ "ha" for an $input:input$ of 1. This function $returns:prints$ an additional "haa" for an $input:input$ greater than 1 
        """
        
  subset: middle_failure
- *id046
- __index_level_0__: 1745
  problem: laugh
  entrypoint: laugh
  assertions: |-
    assert laugh(4) == "haaaa haaa haa ha"
    assert laugh(1) == "ha"
    assert laugh(3) == "haaa haa ha"
  username: student72
  submitted_text: |-
    Produce a string, with each word starting with h and then however many a's the input says. Decrease the count of a's by one following the h for each word after. Stop when a = 2.
  prompt: |-
    def laugh(size):
        """
        $Return:Produce$ a $string:string$, with each $string:word$ starting with h and then however many a's the $input:input$ says. Decrease the count of a's by one following the h for each $string:word$ after. Stop when a = 2.
        """
        
  subset: middle_failure
